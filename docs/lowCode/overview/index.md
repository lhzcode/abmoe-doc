# 低代码平台

## Pro-Code Low-Code No-Code

Pro-Code伴随着云原生、开发中台、WebIDE等理念与技术的发展而兴起，相比传统编程，Pro-Code更强调云端化、场景化、容器化、工具扩展、API扩展、代码托管以及更便利的DevOps等特点。

Low-Code在Pro-Code的基础上更进一步，Low-Code以Pro-Code为基础（保留编写代码的能力），将软件的生产过程变成组装各类“预制件”的过程，Pro-Code面向的是专业开发工程师，Low-Code提供了部分面向业务人员开发的能力。

No-Code相比于Low-Code，直接的体现是在开发过程中必须要编写代码的比例大幅减少。

这三者目前没有明确的划分，但是如果按照Pro-Code -> Low-Code -> No-Code的过渡顺序，越往后```图形化配置/编排```占比越大，```文本型DSL```占比越小

## 什么是可视化搭建系统

表单搭建、中后台应用搭建、BI 仪表盘搭建、大屏搭建都算可视化搭建，因为它们都是在一个画布上拖拖拽拽完成的。

那么组件配置表单算搭建吗？聚焦单组件分析的可视化探索呢？幻灯片呢？

比如组件配置表单，它基于 UI 组件树抽象的话，就是可视化搭建，但如果基于表单结构抽象，就是 JsonSchema，但真的所有业务场景都是数据完全映射 UI 吗？不一定，因为 UI 可以为了用户操作方便而加入更多辅助元素，甚至把一个属性拆成多个 UI 填写，所以基于可视化搭建，也就是 UI 组件树抽象的一定可以覆盖所有表单场景，但不一定是描述效率最高的方式。

如果每种可视化搭建场景都定义一套协议与实现，那按照搭建平台的复杂度，想同时维护两个类搭建平台的成本一定是两倍，而且不同维护人员很难交流。又或者某些可以按照搭建思路解决的场景，因为实现时经验不足，没有进行抽象，甚至进行了另一套定制抽象，回过头来看可能积重难返，团队不得不接受多套笨重实现的现状。

所以建议将这些场景都视为可视化搭建场景，用一套接口描述结构、API 方法，让看似百花齐放的编辑器之下拥有统一的上下文与实现。

## 可视化搭建的分层

对于不同种类的可视化搭建平台，我们尝试寻找其分层设计的最大公约数。如果把可视化搭建底层设定为逻辑层，即这个层是 UI 无关的，仅关心组件树结构、逻辑功能，那么对于每种平台的分层应该是这样的：

1. 表单搭建：逻辑层、表单联动协议层、表单控件、业务层。
2. 中后台应用搭建：逻辑层、应用联动协议层、应用控件、业务层。
3. BI 仪表盘：逻辑层、筛选联动协议层、可视化控件、业务层。
4. 大屏搭建：逻辑层、画布编辑控制器层、可视化控件和基础图形控件、业务层。

最底层的逻辑层应该可以统一所有类型搭建系统，并成为开发人员统一上下文的。它可以包含以下基础能力：

1. 定义组件树结构。
2. 定义组件元信息。
3. 按照组件树结构递归渲染画布。
4. 支持布局、取数、联动、筛选、校验等一系列拓展能力，业务可根据需要定制。
5. 提供所有业务层都需要的能力，比如性能优化的组件冻结、状态管理、对组件树增删改查的 API。

在逻辑层完备后，再开发上层应用就会轻松很多，只要注册组件、根据业务需要在组件树初始化或组件初始化，或组件元信息注册时添加定制逻辑，与系统功能对接，并补充业务特色的如自定义布局能力，这样就可以用简单的三言两语说清楚整个系统是如何设计的。

## 逻辑层存在的必要性

再回到问题的根源：对逻辑层做统一的抽象到底是不是多余的？

要回答这个问题，需要先了解我们手头里有哪些工具：基础开发工具 html、js、css，并且 html 也提供了一套标准化的 xml 结构；vue、react 等开发框架，基础组件、应用生命周期与事件定义。理论上基于这些，我们就可以直接上手写一个可视化搭建平台了，似乎也可以不抽象。但真正要上手时，一定会遇到以下几个通用问题需要处理：

**定义组件树结构**

无论做表单搭建、报表搭建、大屏搭建还是脑图画布，第一个想到的肯定是如何描述这个画布结构，而无论画布是横着排还是竖着排，横竖都是一棵树。HTML 树不能直接搬过来，一是 HTML 树的完整结构太大而我们需要的更精简的结构，二是业务层框架一般都先有一套虚拟树再转化为 dom 树，因果关系也没法反过来。而这棵树也完全可以做最大程度的抽象，即定义组件 ID、组件名、属性（Props）、子节点。

**定义对组件树增删改查函数**

有了组件树肯定需要对其进行增删改查操作，因为无法基于 document API，上层框架如 vue、react 也不提供对任何标准组件树的增删改查 API，这部分能力势必要手动实现。

**生命周期**

假设完全依赖 React 框架提供的组件生命周期，是可以完成大部分业务逻辑，但这意味着定义不够精细化。比方说，我们在组件 Mount 的实际监听了联动、实现取数、设置冻结等等效果，虽然也可以实现，但会遇到要不要抽象的问题：

- 如果不抽象，业务代码就会乱糟糟的，比较难读。
- 如果抽象，就要把联动、取数、冻结等等模块归类，封装成函数，甚至可以提供主动调用机制，UI 与逻辑解耦，但当业务层精细的去做这件事就会发现，这就是在做框架层的抽象工作，所以还不如一开始就把这些生命周期抽象到框架里。

逻辑层有两个核心结构，第一个是组件树结构，包含了对每个组件实例的定义；第二个是组件元信息结构，包含了对每个组件的元信息描述，大概如下图所示：

<img width=400 src="https://user-images.githubusercontent.com/7970947/211183628-75469a31-54cf-446a-9df8-a18bb41508db.png">

逻辑层的难点就是在元信息定义足够多、足够通用的生命周期回调函数，并且这些回调函数还能尽可能的功能正交。

**组件渲染**

通常一棵树按照 json 结构描述自顶向下自动渲染就可以了，但也有一些时候，比如内嵌一个富文本组件，而富文本内又嵌入一些画布组件，这些组件需要像普通画布组件一样可交互，此时就有 **渲染一个不存在于组件树的组件实例** 的需求，而这样的动态组件又要无感知的满足上面所说的各类生命周期，这也是不小的工作量。

**功能的拓展抽象**

等可视化搭建平台正式维护时，就至少会遇到组件版本升级、不同类型的布局方案对接、三方组件注册等需求，这些功能如何加入到现有的搭建平台，而不让其他功能感知，是需要精心设计的。如果逻辑层把这一点抽象好，在每个功能设计一个钩子，实现一个功能时无需感知其他功能，那平台的功能拓展就会保持一个恒定的速度，不随功能增加而变得难以维护。

可见，可视化搭建不断迭代的过程就是自身不断抽象的过程，逻辑层实现的好坏直接影响到后期的维护性与拓展性，所以好好设计逻辑层可以让开发事半功倍。

## 组件配置表单要不要用搭建方案做

组件配置直接用表单方案而不是搭建，似乎是最容易想到的。但当每个组件都要自定义配置，我们就不得不选择基于 JsonSchema 描述的表单方案，但这与搭建应用本身的技术栈割裂了，随着联动功能的要求越来越多，会越来越发现小小的表单渲染引擎维护得越来越复杂，甚至复杂度与画布不分上下，此时再叹息两边技术栈不统一就已经晚了。

换个角度想一下，搭建应用不也要考虑组件间联动吗？从表单值能力来看，搭建场景并不要求每个组件都拥有一个值，反倒是可以将组件任意 props 属性看作表单值更具有 “弹性”，我们可以拓展任意 Key 作为表单值。

另外，从数据结构触发来描述表单看似很美好，但当表单变得越来越复杂，UI 越来越定制后，势必引入新的 UI 节点或者新的结构描述，与其后期拓展到一个不纯净的 JsonSchema 结构，不如一开始就放弃这个幻想，用 UI 组件树结构描述表单，这样事情就变得简单了：“先描述组件树，再定义每个节点分别用什么组件渲染，响应表单的哪部分 Key”。


<!-- # [WIP]为什么我们需要低代码

//todo 百度搜索指数/谷歌搜索指数 简单分析增长情况

# 技术方案

//todo 架构图

构成如下：

- 搭建平台前端
  - 搭建页面
    - 组件面板
      - 基础组件
        - 文本
        - 按钮
        - 图片
        - 输入
      - 容器组件
        - 表单组件
        - 布局组件
      - 低码组件资源平台
        - 低码组件开发脚手架
        - 组件资源解析sdk
        - 低码组件仓库
    - 画布
      - PC端
      - H5端
      - 小程序
    - 配置面板
      - 属性组件
        - 原子组件
  - 底层能力
    - 拖拽定位 -> 组件面板
    - 事件系统 -> 画布
    - 路由管理 -> 配置面板
- 中间渲染层
  - schema解析器
  - 前端资源
    - 组件资源
    - 渲染器资源
    - json Schema
- 服务层
  - 页面访问
  - 页面管理
  - 页面发布
  - 页面预览
  - 页面下线
  - 页面回滚
- 数据层
 - db

# 整体流程
// todo 面板截图
一般来讲一个低代码平台前端核心由三部分组成分别为：组件面板、画布、配置面板。

正常的搭建过程一般是从左侧组件面板中拖拽组件到画布中，之后选中该组件使用右侧的配置面板对该组件的样式、事件等内容进行配置，使用不同的组件最终直到一个完整的页面生成，过程类似搭积木，当然在搭建的过程中也需要有预览功能等模拟浏览器真实环境对搭建产物进行调试。

// todo 组件之间关系描述（schema标准）横向对比

有了描述所有组件之间父子关系的树，要构成完整页面我们还需要有用来拼装完整页面的组件（可以是一个普通 React 或者 Vue 组件），以及一个渲染器逻辑用来递归遍历这棵树将所有的组件拼装在一起构成完整页面。

这样我们低代码搭建平台生成完整页面的流程就很清晰了如下图所示：

// todo 流程图

人（访问） -> 低代码搭建平台（拖拽）-> 生成页面 json tree（保存）-> 渲染层预览（node或浏览器）

页面渲染请求 -> 渲染层（node或浏览器）（遍历json tree）-> 拼装出所有组件cdn地址（组件cdn、json tree、渲染器cdn插入html）-> 完整html

当我们访问低代码搭建平台，通过拖拖拽拽生成的页面时本质上是生成了一份 json，这份 json 描述了页面中所有使用的组件以及这些组件之间的父子关系，当我们保存或者发布页面时这份 json 会被进行保存。

通常由 node 的 bff 层根据这份 json 来拼装出完整的 html，具体细节是首先遍历这份 json 得到页面中所有使用到的组件名称比如：nav组件、root组件，由组件名称根据固定格式（就是具体组件资源发布的源）拼装出对应的组件 cdn 地址，之后将 json、组件 cdn 资源、渲染器 cdn 资源插入在一个 html 中，这样便形成一个我们从用户端访问的由低代码搭建平台生成的html页面。

// todo  https://www.npmjs.com/package/re-resizable

// todo 详细技术方案 组件布局与拖拽、组件事件系统、多页面路由系统、交互系统、配置面板、组件拆分及开放能力、PC及H5两端适配、表单搭建

# 国内主流低代码平台应用场景

# 对比表格

| 低码方案 | 开发团队 | 引擎 | 适用场景 | schema | 事件 |
| -------- | -------- | ---- | -------- | ------ | ---- |
| Low-Code Engine|阿里|

## 阿里 Low-Code Engine

阿里低代码引擎是一套开箱即用的低代码平台开发框架，其定义已不仅仅是低代码平台而是一个专注于生产低代码平台的引擎，核心提供了组件开发脚手架、定义了物料接入规范，甚至还有造物平台可对低代码物料进行管理、通过配置化方式生成低代码组件。

同时其提供了出码能力，有很高的使用自由度，可以在产物的基础之上进行二次编辑，但缺点是交互复杂度比较高，上手成本大。

适用场景：公司内部中后台系统，供技术人员使用。 

## 轻流、码匠

轻流是一个可商用的针对企业报销、CRM、设备管理等开发的一个中后台无代码开发平台，交互友好，上手成本低，可通过图形化的方式实现逻辑编排。

码匠也是类似针对中后台领域，底层基于国外开源框架 appsmith 具有优秀的拖拽能力，搭建平台和数据库打通，可以快速实现全栈应用。

## shopify、wix

shopify 是世界最受欢迎的低代码建站平台之一，提供丰富的模版，可以快速搭建出属于自己的商店，拥有友好的 SEO、商品管理等能力，是外贸企业建站的首选。

wix 同样是针对建站领域，其和 shopify 不同点是其组件布的局能力更强，拥有更自由的搭建能力，可对设计稿有更好的还原度。

## webflow

webflow 是更偏向于官网搭建领域的低代码平台，拥有最强大的布局、定位能力，可以实现官网复杂的 UI 和交互效果，上线时间长老牌低代码平台，估值超1亿美金。

## 微软 powerapps

微软的低代码 平台在使用上就像是使用使用 word 一样，具有复杂且全面的功能，但对新手很不友好，可能只是微软出于战略角度开发的一款产品。

## 网易数帆、腾讯微搭

网易数帆和腾讯微搭可以放在一起看，都是做建站方向，虽然功能齐全，但交互十分不友好，没有什么出彩点。

## ZION 无代码

ZION无代码是专注于小程序领域的低代码搭建平台，可以实现一个完整小程序应用的搭建，有自己的能力特色和护城河，画布大小可以无效缩放，适用营销、留资、客户运营等场景。

## 总结
如果是对客的低代码搭建平台核心不在于功能有多复杂、能力有多强大，而是其在垂直领域是否足够深入、交互是否友好，有自己的特点才有存在的意义，这其中比较好的是拥有快速生成任意低代码平台的阿里 lowcode engine、拥有可靠建站能力的 shopify、拥有最强大布局能力的 webflow、拥有完整小程序搭建能力的 ZION。

# 低代码&AIGC

// todo 调研vercel的最新产品

低代码平台和AIGC结合一般有两种方案，一种是通过大模型技术生成符合低代码格式的低代码组件，同时生成相应的样式配置，最终通过低代码搭建平台进行二次编辑，但该方案在目前还是太超前，技术难点高，还没有商业化的案例。

另外一种方案是大模型核心负责页面样式、文案等配置，可提供针对不同领域场景的配色、主题方案，再由相应的桥阶层来转化为低代码的 json tree，最后再由 json tree 来结合相应的低代码组件渲染页面，相当于组件是确定的，但组件的样式等配置由大模型来生成。


# [WIP]微前端选型 -->
